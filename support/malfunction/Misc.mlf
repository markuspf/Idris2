; utf8-string representation:
;
; int 0: empty string
; block/tag1 (int ofs) (int len) (byte vector bs): non-empty string
;
; this is meant to be compatible with an Idris representation
(module
  ; uncons:
  ;   utf8-string ->
  ;     int 0: empty string
  ;     block/tag1 (int head) (utf8-string tail)
  ;     int 3: decoding error
  ;
  ; this is meant to be compatible with an Idris representation
  ($utf8-uncons
    (lambda ($str)
      (switch $str
        (0 0)  ; empty string
        ((tag 0)
          (let
            ($len (field 1 $str))
            ($ofs (field 2 $str))
            ($bytes (field 3 $str))
              (switch $len
                (0 0)  ; empty string
                (_
                  (let ($h (load.byte $bytes $ofs))
                    (if (< $h 128)
                      ; character encoded as single byte (ascii range)
                      (block (tag 1)
                        $h
                        (block (tag 1)
                          (+ $ofs 1)
                          (- $len 1)
                          $bytes))
                      (if (< $h 192)
                        ; this is a continuation byte!
                        3  ; decoding error
                        (if (< $h 224)
                          ; character encoded in two bytes
                          (if (< $len 2)
                            3  ; decoding error
                            (block (tag 1)
                              (|
                                (<< (& $h 31) 6)
                                (& (load.byte $bytes (+ $ofs 1)) 63))
                              (block (tag 1)
                                (+ $ofs 2)
                                (- $len 2)
                                $bytes)))
                          (if (< $h 240)
                            ; character encoded in three bytes
                            (if (< $len 3)
                              3  ; decoding error
                              (block (tag 1)
                                (|
                                  (<< (& $h 15) 12)
                                  (<< (& (load.byte $bytes (+ $ofs 1)) 63) 6)
                                  (& (load.byte $bytes (+ $ofs 2)) 63))
                                (block (tag 1)
                                  (+ $ofs 3)
                                  (- $len 3)
                                  $bytes)))
                            ; character encoded in four bytes
                            (if (< $len 4)
                              3  ; decoding error
                              (block (tag 1)
                                (|
                                  (<< (& $h 7) 18)
                                  (<< (& (load.byte $bytes (+ $ofs 1)) 63) 12)
                                  (<< (& (load.byte $bytes (+ $ofs 2)) 63) 6)
                                  (& (load.byte $bytes (+ $ofs 3)) 63))
                                (block (tag 1)
                                  (+ $ofs 4)
                                  (- $len 4)
                                  $bytes)))))))))))))))

  ($utf8-cons
    (lambda ($c $str)
      (let
        ($clen
          (if (< $c 128) 1
            (if (< $c 2048) 2
              (if (< $c 65536) 3
                4))))
        ($origlen
          (switch $str
            (0 0)
            ((tag 1) (field $str 1))))
        ($bytes
          (switch $str
            (0 (makevec.byte $clen 0))
            ((tag 1) (let
              ($ofs (field $str 0))
              ($len (field $str 1))
              ($src (field $str 2))
              ($dst (makevec.byte (+ $clen $len) 0))
              (rec
                ($blit (lambda ($ofs-src $ofs-dst $n)
                  (switch $n
                    (0 0)
                    (_ (seq
                      (store.byte $dst $ofs-dst (load.byte $src $ofs-src))
                      (apply $blit (+ $ofs-src 1) (+ $ofs-dst 1) (- $n 1))))))))
              (_ (apply $blit 0 $clen $len))
              $dst))))
        (_ (switch $clen
          (1 (store.byte $bytes 0 $c))
          (2 (seq
               (store.byte $bytes 0 (| 192 (& (>> $c 6) 31)))
               (store.byte $bytes 1 (| 128 (& $c 63)))))
          (3 (seq
               (store.byte $bytes 0 (| 224 (& (>> $c 12) 15)))
               (store.byte $bytes 1 (| 128 (& (>> $c 6) 63)))
               (store.byte $bytes 2 (| 128 (& $c 63)))))
          (_ (seq
               (store.byte $bytes 0 (| 240 (& (>> $c 18) 7)))
               (store.byte $bytes 1 (| 128 (& (>> $c 12) 63)))
               (store.byte $bytes 2 (| 128 (& (>> $c 6) 63)))
               (store.byte $bytes 3 (| 128 (& $c 63)))))))

        (block 0 (+ $clen $origlen) $bytes))))

  (export))

; vim: ft=lisp et sw=2 ts=2 sts=2
